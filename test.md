# Порівняння алгоритмів сортування: Insertion Sort, Merge Sort та Timsort (Python)

## Мета роботи
Порівняти час виконання трьох алгоритмів сортування:
- сортування вставками (Insertion Sort)
- сортування злиттям (Merge Sort)
- вбудоване сортування Python .sorted() .sort() (Timsort)

Замір часу виконання виконано за допомогою модуля timeit.  
Метою є емпірично перевірити теоретичні оцінки складності алгоритмів та показати ефективність Timsort на практиці.

## Умови 
Було використано два типи масивів:
1. Випадковий масив — елементи розташовані випадково  
2. Майже відсортований масив — базово відсортований, але з невеликою кількістю випадкових перестановок

Тестувалися масиви таких розмірів: 1000, 5000, 10000

## Результати:

Випадковий масив:

| Розмір (n) | Insertion Sort (сек) | Merge Sort (сек) | Timsort (сек) |
|-----------:|---------------------:|-----------------:|--------------:|
| 1000  | 0.0167 | 0.0018 | 0.0001 |
| 5000  | 0.4586 | 0.0089 | 0.0005 |
| 10000 | 1.7981 | 0.0160 | 0.0012 |

Майже відсортований масив

| Розмір (n) | Insertion Sort (сек) | Merge Sort (сек) | Timsort (сек) |
|-----------:|---------------------:|-----------------:|--------------:|
| 1000  | 0.0019 | 0.0011 | 0.0000 |
| 5000  | 0.0572 | 0.0070 | 0.0002 |
| 10000 | 0.2195 | 0.0140 | 0.0004 |

## Аналіз результатів

1. Insertion Sort
На випадкових масивах час виконання різко зростає зі збільшенням розміру масиву (від 0.0167 для n=1000 до 1.7981 для n=10000), що підтверджує квадратичну складність O(n²).  
На майже відсортованих масивах алгоритм працює значно швидше, оскільки кількість перестановок мінімальна.

2. Merge Sort
Час виконання зростає поступово та стабільно як на випадкових, так і на майже відсортованих масивах, що відповідає теоретичній складності O(n log n).  
Структура даних майже не впливає на швидкодію.

3. Timsort
Показує найкращі результати в усіх тестах.  
Особливо помітна перевага на майже відсортованих масивах, де час виконання мінімальний.  
Це підтверджує адаптивність Timsort та ефективність поєднання сортування вставками і злиттям.

## Висновки
- Insertion Sort доцільно використовувати лише для малих або майже відсортованих масивів. На випадкових великих масивах він стає неефективним через складність O(n²).
- Merge Sort має стабільну складність O(n log n) і передбачуваний час роботи, але не використовує переваги частково відсортованих даних.
- Timsort, який використовується у вбудованих алгоритмах Python, є найбільш ефективним у більшості практичних випадків завдяки гібридному підходу та адаптивності до структури даних.

Отримані результати пояснюють, чому в реальних проєктах програмісти зазвичай використовують вбудовані алгоритми сортування Python, а не реалізують власні.
